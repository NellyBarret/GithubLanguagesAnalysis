<!DOCTYPE HTML>
<html>
	<head>
	<meta charset="utf-8">
	<title>Github Languages Analysis</title>
	<meta name="viewport" content="width=device-width, initial-scale=1">

	<link href="https://fonts.googleapis.com/css?family=Raleway:100,300,400,700" rel="stylesheet">
	
	<!-- Animate.css -->
	<link rel="stylesheet" href="css/animate.css">
	<!-- Icomoon Icon Fonts-->
	<link rel="stylesheet" href="css/icomoon.css">
	<!-- Bootstrap  -->
	<link rel="stylesheet" href="css/bootstrap.css">
	<!-- Modernizr JS -->
	<script src="js/modernizr-2.6.2.min.js"></script>
	<!-- D3.js -->
	<script src="https://d3js.org/d3.v5.min.js"></script>
	<!-- Theme style  -->
  <link rel="stylesheet" href="css/style.css">
  <style>
    html {
      scroll-behavior: smooth;
    }

    #btnGoTo:hover > a {
      background-color: white;
      color: rgb(56, 183, 188) !important;
    }
  </style>
	</head>
	<body>
		
	<div class="loader"></div>
	
	<div id="page">

		<header id="header" class="cover" role="banner">
			<div class="container">
        
				<h1 id="title">Github Languages Analysis</h1>
				<!-- <div id="chordDiagDiv"></div> -->
				<img src="logo-github.png" height="150" style="margin-bottom: 5rem; display: block; margin-left: auto; margin-right: auto;">
				<div class="display-t">
					<div class="display-tc">
							<div class="text-center animate-box">
								<!-- <h1>Make your life simpler, try this for free.</h1> -->
								<p>Le service GitHub permet d'héberger et de gérer le développement de logiciels. Il a réussi à se faire un nom depuis son lancement en 2008. Aujourd'hui, GitHub compte 37 millions d'utilisateurs, plus de 100 millions de dépôts (dont 28 millions sont publics). Ainsi, se profile la problématique suivante :</p>
								<h2>Comment caractériser l'évolution des langages utilisés dans les projets déposés sur GitHub ?</h2>
                <p>Notre méthode propose une visualisation interactive de l'évolution de la popularité des langages utilisés sur GitHub ainsi qu'un scénario illsutrant l'utilité de celle-ci.</p>
                
                <button id="btnGoTo" class="btn btn-white btn-outline"><a href="#goto" style="color: white;">C'est parti</a></button>
							</div>
					</div>
				</div>
			</div>
		</header>
		<!-- END #header -->
		
		<div class="services section"><a id="goto"></a> 
			<div class="container">
				<div class="heading text-center">
          <h2>Les aventures d'Alice</h2>
          <p><b>Alice part à la recherche de son stage</b></p>
          <p>Alice est en 3ème année de Licence Informatique à l'Université Lyon 1 et elle cherche un stage dans le développement Web. Elle veut en trouver un qui lui permettra d'apprendre de nouveaux langages et de travailler sur des projets qu'elle pourra ajouter à son portfolio. Elle a passé plusieurs entretiens d'embauche et se demande quelle opportunité est la meilleure. Elle a pris en note les détails de chacun des projets et cherche à savoir lequel sera le plus intéressant pour elle. En utilisant notre visualisation, Alice pourra comparer la popularité des langages qui seront utilisés dans les projets des entreprises qu'elle a contactées. Ainsi Alice pourra choisir l'entreprise qui lui propose un projet avec des langages de programmation très populaires.</p>

          <p><b>Alice a besoin d'aide</b></p>
          <p> Alice a maintenant réussi à trouver le stage de ses rêves et compte en profiter au maximum pour s'épanouir et apprendre ! Seulement, son maître de stage lui propose deux langages de programmation différents pour le back-end mais Alice ne sait pas vraiment lequel choisir. Grâce à notre visualisation, elle pourra trouver un langage qui sera complémentaire à celui utilisé côté front-end. En effet, elle pourra observer comment les langages sont associés entre eux et ainsi déterminer le meilleur compromis.</p>

          <p><b>Alice a bientôt fini son stage</b></p>
          <p>Alice est maintenant bienôt à la fin de son stage et elle doit s'attaquer à son rapport de stage. Elle souhaite faire une section avec un état de l'art sur les technologies actuelles utilisées dans le développement Web. Pour avoir une section reflétant les tendances actuelles en termes de popularité des langages, Alice utilise notre visualisation et a ainsi un large choix pour rédiger son état de l'art. De plus, elle a à sa disposition les liens entre les langages ainsi que différentes métriques ce qui lui permet d'ajouter des chiffres concrets dans son rapport.</p>

          <p><b>Quelques années plus tard...</b></p>
          <p>Alice a réussi avec succès son stage, sa Licence et son Master à l'Université Lyon 1 et est développeuse depuis bientiôt 10 ans dans l'entreprise où elle a effectué son stage. Elle a su acquérir beaucoup de pratique en terme de choix de technologies mais veut tout de même rester à la pointe du progrès. Avec notre visualisation, Alice s'informe sur les poids de chaque langage face aux autres et reste ainsi à la pointe de la technologie.</p>
					<div id="chordDiagDiv"></div>
				</div>
			</div>
    </div>
    
    <div class="services section">
			<div class="container">
				<div class="heading text-center">
					<h2>&Eacute;volution de la popularité des langages utilisés sur GitHub</h2>
					<p>Positionnez votre souris sur un langage ou un lien pour plus de détails. Sélectionnez une année dans le slider pour mettre à jour le diagramme avec les données de l'année sélectionnée.</p>
					<div id="chordDiagDiv"></div>
				</div>
			</div>
    </div>
    
    <div class="services section">
			<div class="container">
				<div class="heading text-center">
					<h2>Récupération et traitement des données</h2>
					<p>Github propose une API REST à l'adresse suivante : <a href="https://api.github.com">https://api.github.com</a>. </p>
					<p>Nous avons récupéré plus de 100 000 dépôts GitHub avec leurs méta-données, c'est-à-dire la liste des langages utilisés, le nombre d'étoiles, le nombre de forks et beaucoup d'autres. Ces données ont été stockées sous la forme de fichiers JSON. Nous avons ensuite transformé ces données pour calculer les différentes métriques et utiliser des données dans la visualisation.</p>
				</div>
			</div>
		</div>
		<!-- END .services -->
		
		

	</div>

	<div class="gototop js-top">
		<a href="#" class="js-gotop"><i class="icon-arrow-up"></i></a>
	</div>
	
	<!-- jQuery -->
	<script src="js/jquery.min.js"></script>
	<!-- jQuery Easing -->
	<script src="js/jquery.easing.1.3.js"></script>
	<!-- Bootstrap -->
	<script src="js/bootstrap.min.js"></script>
	<!-- Waypoints -->
	<script src="js/jquery.waypoints.min.js"></script>
	<!-- Carousel -->
	<script src="js/owl.carousel.min.js"></script>
	<!-- Main -->
	<script src="js/main.js"></script>

	</body>

	<script>
    function scrollTo(hash) {
      location.hash = "#" + hash;
    }

    addChordDiag("https://raw.githubusercontent.com/NellyBarret/GithubLanguagesAnalysis/master/data/data.json");

    function addChordDiag(filepath) {
      /////////////////
      // Data Import //
      /////////////////
      d3.json(filepath).then(function (dataByYear) {
        years = Object.keys(dataByYear).map(y => parseInt(y));
        minYear = d3.min(years);
        maxYear = d3.max(years);
        metrics = [];

        maxLink = 0;

        for (year in dataByYear) {
          ////////////////////////
          // Data Preprocessing //
          ////////////////////////
          data = dataByYear[year];

          // Loading metrics list
          if (year == years[0]) {
            metrics = Object.keys(data.metrics);
          }

          // Normalizing metrics
          var preprocess = d => Math.sqrt(d);

          for (metric in data.metrics) {
            newMetric = data.metrics[metric].map(preprocess);
            var max = Math.max(...newMetric);
            newMetric = newMetric.map(e => e / (max == 0 ? 1 : max));
            data.metrics[metric + "_normalized"] = newMetric;
          }
        }

        ////////////////
        // Parameters //
        ////////////////

        // size
        width = 800;
        height = 450;

        // diagram
        outerRadius = Math.min(width, height) * 0.5;
        innerRadius = outerRadius - 64;
        minArcLength = 20;
        maxArcLength = 60;
        padAngle = .04;
        color = d3.scaleOrdinal(d3.schemeCategory10);
        fill_opacity = 0.67;

        // animation
        background_opacity = 0.2;
        transitionTime = 500;

        ///////////////
        // Interface //
        ///////////////

        year = minYear;
        metric = metrics[0];

        filterMin = 1;
        filterMax = 10000;
        maxPourcentage = 100;
        languageFilter = filterMax;
        languagePourcentage = maxPourcentage;
        linkFilter = filterMax;
        linkPourcentage = maxPourcentage;

        linkMethods = [
          "raw",
          "symetric",
          "language_based" //
        ];

        linkMethod = linkMethods[0];

        const ui = d3.select("body")
                    .append("div");

        //// Years

        ui.append("span")
          .attr("class", "ui_slider")
          .attr("style", "margin: 0 0 0 20px")
          .append("input")
          .attr("id", "yearSlider")
          .attr("type", "range")
          .attr("min", minYear)
          .attr("max", maxYear)
          .attr("value", minYear)
          .on("input", function() {
            year = this.value;
            d3.select("#yearSpan")
              .text(` year ${year}`);
            draw();
        });

        ui.append("span")
          .attr("id", "yearSpan")
          .text(` year ${minYear}`);

        //// Metrics

        ui.append("span")
        	.attr("class", "ui_label")
        	.text("Metric: ");

        const selectMetric = ui.append("select");

        selectMetric.selectAll("option")
          .data(metrics)
          .join("option")
          .attr("value", d => d)
          .text(d => d);

        selectMetric.on("change", function() {
            metric = this.value;
            draw();
        })

        //// Filters

        ui.append("span")
        	.attr("class", "ui_label")
        	.text("Filters: ");

        // Language Filter

        ui.append("span")
          .attr("class", "ui_slider")
          .append("input")
          .attr("id", "languageFilterSlider")
          .attr("type", "range")
          .attr("min", filterMin)
          .attr("max", filterMax)
          .attr("value", filterMax)
          .on("input", function() {
            languageFilter = this.value;
          	languagePourcentage = languageFilter * maxPourcentage / filterMax;
            d3.select("#languageFilterSpan")
              .text(` top ${languagePourcentage}% of languages`);
            draw();
        });

        ui.append("span")
          .attr("style", "padding: 0 20px 0 10px")
          .attr("id", "languageFilterSpan")
          .text(` top ${languagePourcentage}% of languages`);

        // Link Filter

        ui.append("span")
          .attr("class", "ui_slider")
          .append("input")
          .attr("id", "linkFilterSlider")
          .attr("type", "range")
          .attr("min", filterMin)
          .attr("max", filterMax)
          .attr("value", filterMax)
          .on("input", function() {
            linkFilter = this.value;
         		linkPourcentage = linkFilter * maxPourcentage / filterMax;
            d3.select("#linkFilterSpan")
              .text(` top ${linkPourcentage}% of links`);
            draw();
        });

        ui.append("span")
          .attr("style", "padding: 0 0 0 10px")
          .attr("id", "linkFilterSpan")
          .text(` top ${linkPourcentage}% of links`);

        // Link method

        ui.append("span")
        	.attr("class", "ui_label")
        	.text("Link method: ");

        const selectLM = ui.append("select");

        selectLM.selectAll("option")
          .data(linkMethods)
          .join("option")
          .attr("value", d => d)
          .text(d => d);

        selectLM.on("change", function() {
            linkMethod = this.value;
            draw();
        })

        ////////////
        // Events //
        ////////////

        var arc_mouseenter = function(d) {
          svg.selectAll("path").transition().duration(transitionTime)
               .style("opacity", background_opacity);
          d3.select(this).transition()
               .style("opacity", 1);
          svg.selectAll(".ribbon")
             .filter(r => r.source.index === d.index || r.target.index === d.index)
             .each(function (r) {
                d3.select(`#arc_${r.source.index}`).transition()
                  .style("opacity", 1);
                d3.select(`#arc_${r.target.index}`).transition()
                  .style("opacity", 1);
              })
             .transition()
             .style("opacity", 1);
        }

        var arc_mouseleave = function(d) {
          svg.selectAll("path").transition().duration(transitionTime)
               .style("opacity", 1);
        }

        var ribbon_mouseenter = function(d) {
          svg.selectAll("path").transition().duration(transitionTime)
               .style("opacity", background_opacity);
          d3.select(this).transition()
               .style("opacity", 1);
          d3.select(`#arc_${d.source.index}`).transition()
               .style("opacity", 1);
          d3.select(`#arc_${d.target.index}`).transition()
               .style("opacity", 1);
        }

        var ribbon_mouseleave = function(d) {
          svg.selectAll("path").transition().duration(transitionTime)
               .style("opacity", 1);
        }

        /////////////
        // Drawing //
        /////////////

        function draw() {
          d3.select("#chordDiagram").remove();

          svg = d3.select("body").append("svg")
            .attr("id", "chordDiagram")
            .attr("viewBox", [-width / 2, -height / 2 - 7, width, height])
            .attr("font-size", 10)
            .attr("font-family", "sans-serif")
            .style("width", "100%")
            .style("height", "auto");

          ribbon = d3.ribbon()
            .radius(innerRadius);
          arc = d3.arc()
            .innerRadius(innerRadius)
            .outerRadius(d => innerRadius + minArcLength + dataByYear[year].metrics[metric + "_normalized"][d.index] * (maxArcLength - minArcLength));
          chord = d3.chord()
            .padAngle(padAngle)
            .sortSubgroups(d3.descending)
            .sortChords(d3.descending)

          filtered = filterData(languagePourcentage, linkPourcentage, linkMethod,
                                metric, dataByYear[year]);
          filteredLanguages = filtered[0];
          filteredMatrix = filtered[1];

          chords = chord(filteredMatrix);

          group = svg.append("g")
            .attr("id", "arcs")
            .selectAll("g")
            .data(chords.groups)
            .join("g");

          group.append("path")
              .attr("id", d => `arc_${d.index}`)
              .attr("fill", d => color(d.index))
              .attr("stroke", d => color(d.index))
              .attr("d", arc)
              .on("mouseenter", arc_mouseenter)
              .on("mouseleave", arc_mouseleave);

          group.append("text")
              .each(d => { d.angle = (d.startAngle + d.endAngle) / 2; })
              .attr("dy", ".35em")
              .attr("transform", d => `
                rotate(${(d.angle * 180 / Math.PI - 90)})
                translate(${innerRadius + 10})
                ${d.angle > Math.PI ? "rotate(180)" : ""}
              `)
              .attr("text-anchor", d => d.angle > Math.PI ? "end" : null)
              .text(d => newLanguages[d.index]);

          svg.append("g")
            .attr("id", "ribbons")
            .attr("fill-opacity", fill_opacity)
            .selectAll("path")
            .data(chords)
            .join("path")
              .attr("class", "ribbon")
              .attr("id", d => `ribbon_${d.source.index}_${d.target.index}`)
              .attr("stroke", d => d3.rgb(color(d.source.index)).darker())
              .attr("fill", d => color(d.source.index))
              .attr("d", ribbon)
              .on("mouseenter", ribbon_mouseenter)
              .on("mouseleave", ribbon_mouseleave);
        }

        draw();

        function filterData(languagePourcentage, linkPourcentage, linkMethod,
                            metric, data) {
          languages = data.languages;
          matrix = data.matrix;
          metrics = data.metrics;
          newMatrix = [];

          languageFractile = languagePourcentage / 100;

          linkFractile = linkPourcentage / 100;
          links = {};

          // Copying the matrix

          for (i = 0; i < matrix.length; ++i) {
            newMatrix.push(matrix[i].slice());
          }

          // Keeping only top `languageFractile` links

          newLanguages = languages.slice();
          indexToMetric = {};

          for (i = 0; i < languages.length; ++i) {
            indexToMetric[i] = metrics[metric][i];
          }

          bestLanguages = Object.entries(indexToMetric).sort(([k1, v1], [k2, v2]) => v1 < v2);
          nbLanguages = languages.length;

          languagesToDelete = bestLanguages.slice(Math.ceil(nbLanguages * languageFractile), nbLanguages).map(entry => parseInt(entry[0]));

          languagesToDelete = languagesToDelete.sort().reverse();

          for (i of languagesToDelete) {
            newLanguages.splice(i,1);
            newMatrix.splice(i,1);

            for (row of newMatrix) {
              row.splice(i,1);
            }
          }

          // Changing links format and registering them for sorting

          for (i = 0; i < newMatrix.length; ++i) {
          	for (j = 0; j < newMatrix.length; ++j) {
              if (i < j) {
                if (linkMethod === "symetric") {
                  min = Math.min(metrics["number_of_projects"][i], data.metrics["number_of_projects"][j]);
                  newMatrix[i][j] /= min;
                  newMatrix[j][i] /= min;
                }
                else if (linkMethod === "language_based") {
                  newMatrix[i][j] /= metrics["number_of_projects"][i];
                  newMatrix[j][i] /= metrics["number_of_projects"][j];
                }

                links[i * newMatrix.length + j] = newMatrix[i][j] + newMatrix[j][i];
              }
              else if (i == j) {
                newMatrix[i][j] = 0;
              }
            }
          }

          // Keeping only top `linkFractile` links

          bestLinks = Object.entries(links).sort(([k1, v1], [k2, v2]) => v1 < v2);
          nbLinks = bestLinks.length;

          linksToDelete = bestLinks.slice(Math.ceil(nbLinks * linkFractile), nbLinks);
          for (const [k,_] of linksToDelete) {
            i = k / newMatrix.length | 0;
            j = k % newMatrix.length;
            newMatrix[i][j] = 0;
            newMatrix[j][i] = 0;
          }

          return [newLanguages, newMatrix];
        }
      });
    }
	</script>
</html>

